use crate::treepp::{script, Script};

use crate::hash::sha256::sha256;

use crate::signatures::winternitz::checksig_verify;
use crate::signatures::winternitz::generate_public_key;

// inputs are previous merkel state root in bytes and its signatures (i.e. hashes generated by sign_digits), in that order
pub fn construct_script1(winternitz_private_key: &str, original_merkel_state_root : Vec<u8>) -> Script {

    let public_key = generate_public_key(winternitz_private_key);

    script!{
        { checksig_verify(&public_key) }
        // now we have the 20 bytes of the sha256 hash that was signed by the winternitz signatures

        // reverse these 20 bytes, and push each of these to altstack
        for i in 0..20 {
            {19-i} OP_ROLL OP_TOALTSTACK
        }

        // duplicate 32 byte data
        for _ in 0..32 {
            {32-1} OP_PICK
        }

        // find 32 byte sha256 hash of the 32 byte data on the stack, drop its first (32-20) excess bytes
        { sha256(32) }
        for i in 0..(32-20) {
            OP_DROP
        }

        // compare both the hashes, if compare fails we quit with failure
        for i in 0..20 {
            OP_FROMALTSTACK
            OP_EQUALVERIFY
        }

        // LOGIC STARTS HERE
        
        // comparing the original_merkel_state_root with the one provided in data
        // only returns true if lesser than 32 limbs are equal
        OP_0 OP_TOALTSTACK
        for i in 0..32 {
            {original_merkel_state_root[i]} OP_EQUAL
            OP_FROMALTSTACK OP_ADD OP_TOALTSTACK
        }
        OP_FROMALTSTACK
        {32} OP_EQUAL OP_NOT
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::run;
    use crate::signatures::winternitz::sign_digits;
    use sha2::{Digest, Sha256};

    // The secret key
    const MY_SECKEY: &str = "b138982ce17ac813d505b5b40b665d404e9528e7";


    #[test]
    fn test_bitvm20_script1() {
        // The message to sign
        #[rustfmt::skip]

        // last 20 bytes of the merkel root hash
        let merkel_root: Vec<u8> = vec![0x01, 0x02, 0x0a, 0x0b, 0x11, 0x12, 0x2a, 0x2b,
                                    0x31, 0x03, 0x3a, 0x03, 0x44, 0x14, 0x24, 0xfb,
                                    0xa1, 0x02, 0xba, 0xcb, 0x1e, 0xd2, 0xea, 0x2f,
                                    0x31, 0xa3, 0xba, 0x0c, 0x44, 0xe4, 0xff, 0xfb];
        let mut hasher = Sha256::new();
        hasher.update(merkel_root.clone());
        let merkel_root_sha256 = hasher.finalize();
        let mut merkel_root_hash : [u8; 40] = [0; 40];
        for i in 0..20 {
            merkel_root_hash[2*i] = merkel_root_sha256[12+i] & 0xf;
            merkel_root_hash[2*i+1] = merkel_root_sha256[12+i] >> 4;
        }
        let public_key = generate_public_key(MY_SECKEY);

        println!("merkel_root : {:x?}", merkel_root);
        println!("merkel_root_hash : {:x?}", merkel_root_hash);

        let script = script! {
            for x in (&merkel_root).iter().rev() {
                {(*x)}
            }
            { sign_digits(MY_SECKEY, merkel_root_hash) }
            { construct_script1(MY_SECKEY, merkel_root.clone()) }
        };

        println!(
            "script 1 size:\n \t{:?} bytes",
            script.len(),
        );

        run(script! {
            for x in (&merkel_root).iter().rev() {
                {(*x)}
            }
            { sign_digits(MY_SECKEY, merkel_root_hash) }
            { construct_script1(MY_SECKEY, merkel_root.clone()) }

            OP_0 OP_EQUAL // on correct execution this script must fail
        });
    }
}