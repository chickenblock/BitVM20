use crate::treepp::{script, Script};

use crate::hash::sha256::sha256;

use crate::signatures::winternitz::checksig_verify;
use crate::signatures::winternitz::generate_public_key;

fn duplicate_32_byte_numbers(a : usize) -> Script {
    script! {
        for _ in 0..32 {
            {a + 31} OP_PICK
        }
    }
}

// leaves signum(a - b) on the stack
// <0 -> a < b
//  0 -> a = b
// >0 -> a > b
fn compare_32_byte_numbers(a : usize, b : usize) -> Script {
    script! {
        // push current result, initially 0 to alt stack
        OP_0
        OP_TOALTSTACK
        for i in 0..32 {
            // create a duplicate result to stack
            OP_FROMALTSTACK
            OP_DUP

            // compare it with 0
            OP_0
            OP_EQUAL
            OP_IF

                OP_DROP // drop previous result, being 0

                // pick the relevant limbs and substract them
                {b + 31 - i} OP_PICK
                {a + 32 - i} OP_PICK
                OP_SUB
                OP_TOALTSTACK

            OP_ELSE // result is non zero, push the +1, or -1, back to alt stack

                OP_TOALTSTACK
            
            OP_ENDIF
        }

        // pop result back from altstack
        OP_FROMALTSTACK
    }
}

fn generate_sum_carry(a : usize, b : usize) -> Script {
    script! {
        OP_0 OP_TOALTSTACK // pushing the 0 carry

        for i in 0..32 {
            {a + i} OP_PICK
            {b + i + 1} OP_PICK
            OP_ADD
            OP_FROMALTSTACK // bring carry to the stack
            OP_ADD  // add carry
            {0xff} OP_LESSTHAN
            OP_TOALTSTACK
        }

        OP_FROMALTSTACK
    }
}

// inputs are from-entry nonce and balance (8 + 32 = 40 bytes), to-entry balance (32 bytes), value (32 bytes) and its signatures (i.e. hashes generated by sign_digits), in that order
// addresses from top => value -> 0, to-entry balance -> 32, from-entry balance -> 64, from-entry nonce -> 96
pub fn construct_script4(winternitz_private_key: &str) -> Script {

    let public_key = generate_public_key(winternitz_private_key);

    script!{
        { checksig_verify(&public_key) }
        // now we have the 20 bytes of the sha256 hash that was signed by the winternitz signatures

        // reverse these 20 bytes, and push each of these to altstack
        for i in 0..20 {
            {19 - i} OP_ROLL OP_TOALTSTACK
        }

        // duplicate 32 byte data
        for _ in 0..(40 + 32 + 32) {
            {(40 + 32 + 32)-1} OP_PICK
        }

        // find 32 byte sha256 hash of the (40 + 32 + 32) byte data on the stack, drop its first (32-20) excess bytes
        { sha256(40 + 32 + 32) }
        for i in 0..(32-20) {
            OP_DROP
        }

        // compare both the hashes, if compare fails we quit with failure
        for i in 0..20 {
            OP_FROMALTSTACK
            OP_EQUALVERIFY
        }

        // LOGIC STARTS HERE

        // initialize the number of checks passed
        OP_0 OP_TOALTSTACK
        
        // balance of the to-entry user will not overflow, on adding value
        {generate_sum_carry(0, 32)}
        OP_0 OP_EQUAL
        OP_FROMALTSTACK OP_ADD OP_TOALTSTACK

        // balance of the from-entry user must be greater than or equal to value
        {compare_32_byte_numbers(0, 64)}
        OP_0 OP_LESSTHANOREQUAL
        OP_FROMALTSTACK OP_ADD OP_TOALTSTACK

        // count the number of limbs of the nonce that equal 0xff
        OP_0 OP_TOALTSTACK
        for i in 0..8 {
            {96+i} OP_PICK
            {0xff} OP_EQUAL
            OP_FROMALTSTACK
            OP_ADD
            OP_TOALTSTACK
        }
        OP_FROMALTSTACK {8} OP_EQUAL OP_NOT
        OP_FROMALTSTACK OP_ADD OP_TOALTSTACK

        OP_FROMALTSTACK {3} OP_EQUAL OP_NOT
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::run;
    use crate::signatures::winternitz::sign_digits;
    use sha2::{Digest, Sha256};
    use num_bigint::{BigUint, RandomBits};

    // The secret key
    const MY_SECKEY: &str = "b138982ce17ac813d505b5b40b665d404e9528e7";


    #[test]
    fn test_bitvm20_script4() {
        // The message to sign
        #[rustfmt::skip]

        let value : BigUint = BigUint::parse_bytes(b"0", 10).expect("failed to parse value");
        let to_balance : BigUint = BigUint::parse_bytes(b"0", 10).expect("failed to parse to_balance");
        let from_balance : BigUint = BigUint::parse_bytes(b"0", 10).expect("failed to parse from_balance");
        let from_nonce : u64 = 0;

        let mut data: Vec<u8> = vec![];
        let temp = value.to_bytes_le();
        for i in 0..32 {
            if i < temp.len() {
                data.push(temp[i]);
            }
            else {
                data.push(0x00);
            }
        }
        let temp = to_balance.to_bytes_le();
        for i in 0..32 {
            if i < temp.len() {
                data.push(temp[i]);
            }
            else {
                data.push(0x00);
            }
        }
        let temp = from_balance.to_bytes_le();
        for i in 0..32 {
            if i < temp.len() {
                data.push(temp[i]);
            }
            else {
                data.push(0x00);
            }
        }
        let mut temp = from_nonce;
        for _ in 0..8 {
            data.push((temp & 0xff) as u8);
            temp >>= 8;
        }

        let mut hasher = Sha256::new();
        hasher.update(data.clone());
        let data_sha256 = hasher.finalize();
        let mut data_hash : [u8; 40] = [0; 40];
        for i in 0..20 {
            data_hash[2*i] = data_sha256[12+i] & 0xf;
            data_hash[2*i+1] = data_sha256[12+i] >> 4;
        }
        let public_key = generate_public_key(MY_SECKEY);

        println!("data : {:x?}", data);
        println!("data_hash : {:x?}", data_hash);

        let script = script! {
            for x in (&data).iter().rev() {
                {(*x)}
            }
            { sign_digits(MY_SECKEY, data_hash) }
            { construct_script4(MY_SECKEY) }
        };

        println!(
            "script 4 size:\n \t{:?} bytes",
            script.len(),
        );

        run(script! {
            for x in (&data).iter().rev() {
                {(*x)}
            }
            { sign_digits(MY_SECKEY, data_hash) }
            { construct_script4(MY_SECKEY) }

            OP_0 OP_EQUAL // on correct execution this script must fail
        });
    }
}